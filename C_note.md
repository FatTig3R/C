# 数据结构与算法的基本概念
**算法：解决方案的准确而完整的描述**

算法不等于程序，也不等于计算方法
## 算法的基本概念

### 基本特性
- 可行性
- 确定性
- 有穷性
- 拥有足够的情报

### 算法设计基本方法
- 列举法
- 归纳法
- 递推
- 递归
- 减半递推法
- 回溯法

### 算法复杂度
 算法复杂度：时间复杂度，空间复杂度

 时间复杂度：执行算法所需要的计算工作量

  - 算法的工作量用算法所执行的基本运算次数来计算
  - 算法的工作量= f(n)

 空间复杂度：算法所需要的**内存空间**


## 数据结构基本概念
数据结构是指相互关联的数据元素的**集合**

数据结构的研究方向：
 - 数据集合中各数据元素之间所固有的逻辑关系，即**数据的逻辑结构**
 - 在对数据进行处理时，各数据元素在计算机中的存储关系，即**数据的存储结构**
 - **对各种数据结构进行运算**

数据的逻辑结构：指反应数据之间的逻辑关系的数据结构
数据的逻辑结构有两个要素：
 - 数据元素的集合，记作D
 - 各元素的前后件关系，记作R

 则数据结构B=(D,R)

 数据的存储结构有顺序、连接、索引等

### 线性结构与非线性结构
数据分为两大类型：线性结构与非线性结构

线性结构的条件：
 - 有且只有一个根节点
 - 每一个节点最多有一个前件，也最多有一个后件

如下图，为线性结构

![线性.jpg](http://upload-images.jianshu.io/upload_images/817492-2722f3b96c48e8f6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

非线性结构：不满足线性结构条件的结构

如下图为非线性结构

![非线性结构](http://upload-images.jianshu.io/upload_images/817492-d2eaca44f0ce09ca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 数据结构与算法的线性数据结构

## 线性表及其存储结构

### 线性表的基本概念
线性表：由一组数据元素构成，数据元素的位置只取决于自己的序号，元素之间的相对位置是线性的

在复杂线性表中，由若干项数据元素组成的数据元素称为**记录**，而由多个记录构成的线性表又称为**文件**

非空线性表的结构特性：

- 有且只有一个根节点a1，它无前件
- 有且只有一个终端节点an，它无后件
- 除跟节点和终端节点外，其他所有节点有且只有一个前件，也有且只有一个后件
- 节点个数n为**线性表的长度**，当n=0时，称为**空表**

### 线性表的顺序存储结构

线性表 的顺序存储结构具有以下**两个基本特点**:

- 线性表中所有元素的所占存储空间是连续的
- 线性表中各数据元素在存储空间中是按照**逻辑顺序**依次存放的

ai的存储地址：

ADR(ai) = ADR(ai) + (i - 1)k，ADR(a1)为第一个元素的地址，k代表每个元素所占的字节数

### 顺序表的插入运算

插入的过程：

- 首先处理三种异常情况
  1. 1 当存储空间已满时为"上溢"错误，不能插入，算法结束
  2. 2 当i > n时，认为在最后一个元素之后插入(n表示已有的长度)
  3. 3 当i < 1时，认为在第1个元素之前插入
- 然后从最后一个元素开始，直到第i个元素，其中每一个元素均往后移动一个位置
- 最后将新元素插入到第i个位置，并且将线性表的长度增加1

### 顺序表的删除运算

删除的过程：

- 首先处理一下2种异常情况：
  - 1 当线性表为空(即n=0)时为"上溢"错误，算法结束
  - 2 当 i < 1 或 i > n时
- 然后从第i+1个元素开始，直到最后一个元素，其中每个元素依次向前移动一个位置
- 最后将线性表的长度减小1

## 栈和队列

### 什么是栈

栈是限定在一端进行插入和删除运算的线性表

- 允许插入与删除的一段称为**栈顶**，反之则称为**栈底**
- 栈按照"先进后出(FILO)"或"后进先出(LIFO)"组织数据
- 栈具有记忆作用
- 用top表示栈顶位置，用bottom表示栈底位置

#### 栈顺序存储及其运算

- 插入元素称为**入栈运算**
- 删除元素称为**退栈运算**
- 读栈顶元素是将栈顶元素赋给一个指定的变量，此时指针无变化

### 什么是队列

队列是指允许在一端(队尾)进行插入，而在另一端(队头)进行删除的线性表

- Rear指针指向队尾，Front指针指向队头
- 队列是"先进先出(FIFO)"或"后进后出(LILO)"的线性表

队列运算包括：
- 入队运算：从队尾插入一个元素
- 退队运算：从队头删除一个元素

#### 循环队列及其运算

循环列表：就是将队列存储空间的最后一个位置绕到第一个位置，形成逻辑上的环状空间，控队列循环使用

循环队列的元素个数　= rear - front

入队运算和退队运算：
- 每进行一次入队运算，队尾指针就进一。当队尾指针rear = m + 1时，则置rear = 1
- 每进行一次退队运算，队头指针就进一。当队头指针front = m + 1时，则置front = 1

## 线性链表

###　线性链表基本概念

线性表的顺序存储的缺点：
- 插入删除时效率低
- 不易扩张
- 多个线性表共享空间时，不已分配空间

数据结构中每个数据节点对应于一个存储单元，这种存储单元被称为**存储节点**，简称**节点**

链式存储方式中，节点有两个组成部分：
- 存放数据元素值的部分，称为**数据域**
- 存放指针的部分，称为**指针域**。用于指向该节点的前一个或后一个节点

链式存储方式既可以用于线性结构，也可以用于非线性结构

线性表的**链式存储结构**称为**线性链表**

线性链表中，HEAD称为头指针，HEAD = NULL (或0)称为**空表**

双向链表中，Llink称为左指针，Rlink称为右指针

带链的栈

带链的队列

### 线性链表的基本运算

线性链表的基本运算：
- 在线性链表中查找指定元素
- 线性链表的插入
- 线性链表的删除

循环链表


# 数据结构与算法的树、查找和排序技术

## 数与二叉树

### 树的基本概念

树是一种简单的**非线性结构**，所以元素之间具有明显的层次特性

- 每一个节点只有一个前件，称为**父节点**
- 没有前件的节点只有一个，称为根节点，简称**根**
- 每一个节点可以有多个后节点，称为该节点的**子节点**
- 没有后件的节点，称为**叶子节点**
- 一个节点拥有的后件个数，称为该节点的**度**
- 所有节点中最大的度，称为**树的度**
- 树的最大层次，称为**树的深度**

![](http://upload-images.jianshu.io/upload_images/817492-d2eaca44f0ce09ca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

###　二叉树及其基本性质

二叉树的特性：
- 非空二叉树只有一个根节点
- 每个节点最有有两颗子树，且分别称为该节点的左子树与右子树

二叉树的度可以为0(叶子节点)，１(只要一颗子树)或2(有两颗子树)

二叉树的性质：
- 在二叉树的第k层上，最多有2k-1(k>=1)个节点
- 深度为m的二叉树最多有2m-1个节点
- 在任意一颗二叉树中，度为0的节点(即叶子节点)总是比度为2的节点多一个
- 具有n个节点的二叉树，其深度至少为[log2n]+1，其中[log2n]表示取log2n的整数部分

满二叉树：除最后一层外，每一层上的所有节点都有两个子节点

![erchashu.png](http://upload-images.jianshu.io/upload_images/817492-9f511961ef3c1b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

完全二叉树：除最后一层外，每一层的节点数都达到最大值;在最后一层上只缺少右边的若干节点(如上图，将G去掉)
- 具有n个节点的完全二叉树深度为[log2n]+1
- 设完全二叉树共有n个节点。如果从根节点开始，按层序(每一层从左到右)用自然数1,2,3,...,n给节点编号(k=1,2,...,n)，有一下结论
  - 1 若k=1，则该节点为根节点，它没有父节点；若k>1，该节点的父节点编号为INT(K/2) (INT->取整)
  - 2 若2k<=n，则编号为k的节点在左子节点编号为2k，否则该节点无子节点
  - 3 若2k+1<=n，则编号为k的节点的右子节点编号为2k+1，否则该节点无右子节点


### 二叉树的存储结构

二叉树通常采用链式存储结构

根据完全二叉树的性质，满二叉树与完全二叉树也可以按层序进行顺序存储

### 二叉树的遍历

二叉树的遍历是指**不重复**的访问二叉树中的所有节点

![qianxubianli.png](http://upload-images.jianshu.io/upload_images/817492-b862d4f7539d95bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**前序遍历(DLR)**：若二叉树为空，则结束返回；否则：
- 访问根节点，
- 前序遍历左子树，
- 前序遍历右子树


	1 -->2 -->5 -->3 -->6


练习1

![lianxi1.png](http://upload-images.jianshu.io/upload_images/817492-f1da13732c64573f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

先访问根节点，所以是A开头(排除A、B)，然后是遍历左子树，所以为ABDYE，再到右子树CFXZ，所以遍历结果为ABDYECFXZ，答案选C





**中序遍历(LDR)**：若二叉树为空，则结束返回；否则：

- 中序遍历左子树，
- 访问根节点，
- 中序遍历右子树


	2 -->5 -->1 -->6 -->3


**后序遍历(LRD)**：若二叉树为空，则结束返回；否则：
- 后序遍历左子树，
- 后序遍历右子树，
- 访问根节点


	5 -->2 -->6 -->3 -->1


	以上遍历都是先从左边开始遍历，而后到右边


## 查找与排序技术

### 查找技术

查找：根据给定的某个值，在查找表中确定一个某关键字等于给定值的数据元素

**顺序查找**的使用情况：
- 线性表为无序表 (大小无规律的表)
- 表采用链式存储结构

**二分查找**只适用于**顺序存储**的有序表，对于长度为n的有序线性表，**最坏情况只需比较log2n次**

**排序**是指将一个无序序列整理成按值非递减顺序排列的有序序列，即是将无序的记录序列调整为有序的记录序列的一种操作

**交换类排序**：借助数据元素之间的相互交换进行排序的一种方法
- **冒泡排序**：对比数据大小，比较相邻的两个数据大小，然后交换。排序后最小的在第一位，最大的在最后一位。**最坏需要比较次数n(n-1)/2**
- **快速排序法**：在表里选定一个值，如果表里的值比选定的值大的就放到选定值的前面，小的就放到选定值的后面。通常效率比冒泡排序效率高。**最坏需要比较次数n(n-1)/2**
- **插入排序法**：将无序的各个元素依次插入已经有序的线性表中
  - 简单插入排序法：**最坏需要比较次数n(n-1)/2**
  - 希尔排序法：把整个线性表分成若干的小序列进行插入，**最坏需要比较次数O(n^1.5)**

**选择类排序**：扫描整个线性表，选出最小的元素，将它交换到表的最前面，然后对剩下的继续用同样的方法，直到子表为空
- 简单选择排序法：**最坏需要比较次数n(n-1)/2**
- 堆排序法：**最坏需要比较次数O(nlog2n)**



练习2

![lianxi2.png](http://upload-images.jianshu.io/upload_images/817492-2a2c0b99da4cdbbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

选D，堆排序法的比较次数是nlog2n





